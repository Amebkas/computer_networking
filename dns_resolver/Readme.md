## Сборка:
```
cd build && cmake .. && make && cd ../
```

## Запуск клиента:
```
./build/DnsResolver google.com A
```

## Примеры входных/выходные данных
### Обычный случай (UDP)
I: `./DnsResolver google.com A`

O: `209.85.233.102`

### Флаг TC
I: `./DnsResolver ietf.org A -d`

O: 
```
[DEBUG] Starting resolution for ietf.org from Root: 198.41.0.4
[DEBUG] Moving to: 199.249.112.1
[DEBUG] Resolving NS: ken.ns.cloudflare.com
[DEBUG] Starting resolution for ken.ns.cloudflare.com from Root: 198.41.0.4
[DEBUG] Switching to TCP for 198.41.0.4
[DEBUG] Moving to: 192.41.162.30
[DEBUG] Switching to TCP for 192.41.162.30
[DEBUG] Moving to: 162.159.0.33
[DEBUG] Moving to: 173.245.59.127
104.16.44.99
```

### AAAA
I: `./DnsResolver google.com AAAA`

O: `2a00:1450:4010:c03::66`

## Обработка флага TC:
1. Отправка UDP-запроса: Клиент отправляет стандартный запрос через `SOCK_DGRAM`.
2. Проверка заголовка: После получения ответа анализируется второй байт заголовка DNS. Извлекается бит TC (маска 0x02 в сетевом порядке байт).
3. Проверка обрезания: Если TC == 1, клиент игнорирует содержимое текущего пакета, так как оно неполное.
4. Переход на TCP:
- Закрывается UDP сокет.
- Создается TCP сокет (`SOCK_STREAM`).
- Устанавливается соединение с тем же IP-адресом сервера на порт 53.
5. Форматирование TCP-запроса: В протоколе DNS через TCP пакету должен предшествовать 2-байтовый префикс, указывающий длину сообщения.
6. Повторный запрос: Отправляется: Длина.DNSзаголовок.Вопрос.
7. Чтение ответа: Клиент сначала считывает 2 байта длины, а затем вычитывает из потока ровно столько байт, сколько указал сервер.
8. Завершение: После получения полного ответа TCP соединение закрывается.