## Обзор архитектуры TCP Клиент-Серверного Приложения

Целью данного проекта является реализация простого клиент-серверного взаимодействия по протоколу TCP на платформе Linux с использованием языка C++. Архитектура приложения основывается на стандартной модели "один клиент - один сервер", где сервер может последовательно обрабатывать подключения от нескольких клиентов.

**1. Общие компоненты и структуры данных**

Проект использует общий заголовочный файл `Common.h`, который содержит определения, необходимые как для клиентского, так и для серверного приложения. Это способствует снижению дублирования кода и централизации общих концепций.

В `Common.h` определена структура `Message`. Эта структура инкапсулирует данные, передаваемые между клиентом и сервером: строковое имя (клиента или сервера) и целое число. Использование этой структуры позволяет обрабатывать сообщения как единый объект, упрощая сериализацию и десериализацию.

Также в `Common.h` реализованы вспомогательные функции для работы с сообщениями:
*   `SerializeMessage` преобразует объект `Message` в строковый формат для передачи по сети.
*   `DeserializeMessage` выполняет обратное преобразование, парся строку и воссоздавая объект `Message`.
*   `SendData` и `ReceiveData` являются высокоуровневыми обертками над системными вызовами `send` и `recv`, используя механизмы сериализации и десериализации `Message`.
*   `IsValidNumber` обеспечивает общую логику валидации диапазона чисел.

**2. Клиентское приложение (`Client.cpp`)**

Клиентская часть приложения предназначена для инициации взаимодействия с сервером. Ее архитектура включает следующие этапы:

2.1. Инициализация и ввод данных. Клиент запрашивает у пользователя целое число от 1 до 100 с помощью функции `GetClientNumber`.

2.2. Установка соединения. Используются функции `CreateClientSocket` для создания TCP-сокета и `ConnectToServer` для установления соединения с заранее заданным IP-адресом и портом сервера.

2.3. Обмен данными. После успешного подключения клиент формирует объект `Message`, содержащий свое имя и введенное число, и отправляет его серверу с помощью `SendData`. Затем клиент ожидает ответ от сервера, используя `ReceiveData`, и получает объект `Message`, содержащий имя сервера и его число.

2.4. Обработка и вывод результатов. Полученные от сервера данные отображаются на консоли вместе с собственными данными клиента, включая сумму двух чисел, посредством функции `ProcessServerResponse`.

2.5. Завершение работы. Сокет корректно закрывается, и приложение завершает выполнение.

**3. Серверное приложение (`Server.cpp`)**

Серверное приложение работает в режиме постоянного ожидания и обработки клиентских запросов. Его архитектура построена следующим образом:

3.1. Инициализация сервера. Функция `CreateAndBindServerSocket` создает TCP-сокет, привязывает его к указанному порту и настраивает опции сокета для повторного использования адреса. Функция `StartListening` переводит сокет в режим прослушивания входящих подключений.

3.2. Основной цикл обработки. Сервер работает в бесконечном цикле, реализованном в `RunServerLoop`, который ожидает новые клиентские подключения с помощью системного вызова `accept`.

3.3. Обработка отдельного клиента. Для каждого принятого подключения вызывается функция `HandleSingleClient`. Эта функция выполняет следующие действия:
*   Получает сообщение от клиента с помощью `ReceiveData` и десериализует его в объект `Message`.
*   Выводит на консоль информацию о клиенте и сервере, включая числа и их сумму.
*   Формирует ответное сообщение с именем сервера и его фиксированным числом (50) и отправляет его клиенту через `SendData`.
*   Проверяет число, полученное от клиента. Если число находится вне диапазона от 1 до 100, сервер интерпретирует это как команду на завершение работы и вызывает `exit(0)`.
*   Закрывает сокет конкретного клиента.

3.4. Завершение работы. В случае завершения работы из-за некорректного числа клиента, все сокеты корректно закрываются.
